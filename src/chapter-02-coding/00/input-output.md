## 输入输出

重视如下情况的输入和输出：

1. 空白符（空格，tab，换行）
2. 数据类型（整数，小数，字符，字符串）
3. 批量读入

重点掌握C语言的：

1. scanf() 输入格式数据
2. gets() 整行字符串，带空格，不读入回车
3. 用printf输出

重点掌握C++语言的：

1. cin 读入格式数据
2. getline(cin,str,n), 整行字符串， 不能识别字符串长度是否与变量长度相符


### C 语言

#### int getchar()

读入单个字符（包括空格回车），返回读入的字符或EOF（操作失败）

```C {.line-numbers}
char ch = getchar();
```

1. 读入任意字符，包括空格和回车
2. 按回车键后开始读取
3. 输入字符多于 getchar() 的次数时，多于的字符被忽略掉

```C {.line-numbers}
while((a[i++]=getchar())!='\n');
```

#### char *gets(char *str)

1. gets() 从标准输入设备读取字符串，以回车结束读取，能够读入空格，使用'\0'结尾，回车符'\n'被舍弃没有遗留在缓冲区。
2. 可以无限读取，不会判断上限，因此使用 gets 不安全，可能会造成溢出
3. gets() 可以读取空回车 

```C {.line-numbers}
char c[100][30];
while(gets(c[i++]))
```

#### int scanf(const char *format [,<参数表>]);

输入基本数据类型（截止于空格、回车、制表符Tab），返回保存的数据个数或负数（操作失败）

scanf("格式控制字符串"，地址列表）;

1. 输入多个数据时，如果格式串没有指定数据分割方式，则用空格、TAB 或回车作为间隔。
2. 没有精度控制
3. 要求给出变量地址
4. 遇到非法数据，即认为输入结束
5. 格式串中如果没有分割字符，则输入的所有字符均有效
6. 格式串中如果有分割字符，则分割字符也要输入
7. 如果输入的数据与所要求格式不符，能编译通过，但执行结果未必正确。

##### scanf 转换说明符

转换说明符由%开始，到转换说明字符结束，具体见 [@tbl:scanf_conversion_specifier]。
%和转换说明字符之间是零到修饰符 （见 [@tbl:scanf_modifier]）。

| 说明符 | 输出说明|
|---|---------------------|
|%c             | 一个字符
|%d             | 一个有符号十进制整数
|%e,%f,%g,%a    | 一个浮点数
|%E,%F,%G,%A    | 一个浮点数
|%i             | 一个有符号的十进制整数
|%o             | 一个有符号的八进制整数
|%p             | 一个指针（一个地址）
|%s             | 一个字符串，第一个非空白符开始，直到下一个空白符结束
|%u             | 一个无符号十进制整数
|%x,%X          | 一个有符号十六进制整数

Table: scanf 转换说明符 {#tbl:scanf_conversion_specifier}

重点掌握：**%c,%d,%f,%s**

##### scanf 转换修饰符

对转换格式的改变和修饰，见 [@tbl:printf_modifier]。

|修饰符 | 意义|
|---|------------------------------|
|*          | 滞后赋值
|^          | 示例："%*d"
|digit(s)   | 最大字段宽度：在达到最大字段宽度或遇到第一个空白字符时，停止对输入项的读取
|^          | 示例："%10s"
|hh         | 把整数读作 signed char 或 unsigned char
|^          | 示例："%hhd","%hhu"
|ll         | 把整数读作 long long 或 unsigned long long
|^          | 示例："%lld" ,"%llu"
|h,l 或 L   | "%hd"和"%hi"指示该值将会存储在一个 short int 中。"%ho"、"%hx"、"%hu"指示该值将会存储在一个 unsigned short int 中。"%ld"和"%li"指示该值将会存储在一个 long 中。"%lo"、"%lx"和"%lu"指示该值将会存储在一个 unsigned long 中。"%le"、"%lf"和"%lg"指示该值以 double 类型存储。将 L（不是 l）与 e、f 和 g 一起使用指示该值以 long double 类型存储。如果没有这些修饰符，d、i、o 和 x 指示 int 类型，e、f 和 g 指示 float 类型。

Table: scanf 修饰符 {#tbl:scanf_modifier}

重点掌握：**%ld,%lf,%10s**

```c {.line-numbers}
while(scanf("%s %d %c %f",st,i,c,f)==1)
    printf("%s ",st);
```
- 输入一行的样例 abc 123 ! 333.33

```C {.line-numbers}
scanf("%*d %*d %*d",&n);
```
- 输入：2004 2005 2006
- n = 2006

```C {.line-numbers}
scanf("%d,%d,%d",&a,&b,&c);
```
- 输入样例：100,22,44

#### int putchar(int ch)

输出单个字符（包括空格回车），返回输出的字符或EOF（操作失败）

#### int puts(const char *p)

把p所指向的字符串输出（截止至空字符'\0'，用回车代替'\0',即自动换行），返回非负整数或EOF（操作失败）

#### int printf(const char *format [,<参数表>])

输出基本数据类型，返回输出的字符个数或负数（操作失败）

printf("%标志格式修饰装换说明 %转换格式 2 %...", 变量 1, 变量 2,...);

格式字符串是以%开头的字符串，在%后面跟有各种格式字符，用来说明数据的类型、形式、长度和小数位数等。

##### printf() 转换说明符

转换说明符由%开始，到转换说明字符结束，具体见 [@tbl:printf_conversion_specifier]。
%和转换说明字符之间是零到多个标志符（ 见 [@tbl:printf_flag]） 和修饰符 （见 [@tbl:printf_modifier]）。

| 说明符 | 输出说明|
|---|---------------------|
|%a | 浮点数、十六进制数字和 p 记数法 (C99)
|%A | 浮点数、十六进制数字和 p 记数法 (C99)
|%c | 一个字符
|%d | 有符号十进制整数
|%e | 浮点数、e 记数法
|%E | 浮点数、E 记数法
|%f | 浮点数、十进制记数法
|%g | 根据数值的不同自动选择%f 或%e，%e 格式在指数小于-4 或者大于等于精度时使用
|%G | 根据数值的不同自动选择%f 或%E，%E 格式在指数小于-4 或者大于等于精度时使用
|%i | 有符号十进制整数（与%d 相同）
|%o | 无符号八进制整数
|%p | 指针
|%s | 字符串
|%u | 无符号十进制整数
|%x | 使用十六进制数字 0f 的无符号十六进制整数
|%X | 使用十六进制数字 0F 的无符号十六进制整数
|%% | 打印一个百分号

Table: 转换说明符及作为结果的打印输出 {#tbl:printf_conversion_specifier}

重点掌握： **%c %d %s %f %e**

##### printf() 的转换说明修饰符

对转换格式的改变和修饰，见 [@tbl:printf_modifier]。

|修饰符 | 意义|
|---|------------------------------|
|flag       | 五种标志 (-、+、空格、#或 0) 见 [@tbl:printf_flag]，可以使用其中零个或多个
|^          | 示例："%-10d"
|digit(s)   | 字段宽度的最小值。如果该字段不能容纳要打印的数或字符串，系统就会使用更宽的字段
|^          | 示例："%4d"
|.digit(s)  | 精度。对于%e、%E 和%f，是将要在小数点右边打印的数字的位数。对于%g 和%G，是有效数字的最大位数。对于%s，是将要打印的字符的最大数目。对于整数，是将要打印的数字的最小位数，如果必要，使用前导零来达到这个位数。只使用“.”表示其后跟随一个零，所以%.f 与%.0f 相同
|^          | 示例："%5.2f" 打印一个浮点数，它的字段宽度是 5，小数点后有两个数字
|h          | 和整数转换说明符一起使用，表示一个 short int 或 unsigned short int 类型值
|^          | 示例："%hd"、"%hx"和"%6.4hd"
|hh         | 和整数转换说明符一起使用，表示一个 signed char 或 unsigned char 类型值
|^          | 示例："%hhd"、"%hhx"和"%6.4hhd"
|j          | 和整数转换说明符一起使用，表示一个 intmax_t 或 uintmax_t 值
|^          | 示例："%jd" 和 "%8jX"
|l          | 和整数转换说明符一起使用，表示一个 long int 或 unsigned long int 类型值
|^          | 示例："%ld" 和 "%8lu"
|ll         | 和整数转换说明符一起使用，表示一个 long long int 或 unsigned long long int 类型值 (C99)
|^          | 示例："%lld" 或 "%8lld"
|L          | 和浮点转换说明符一起使用，表示一个 long double 值
|^          | 示例："%Lf" 和 "%10.4Le"
|t          | 和整数转换说明符一起使用，表示一个 ptrdiff_t 值（与两个指针之间的差相对应的类型）(C99)
|^          | 示例："%td"和"%12ti"
|z          | 和整数转换说明符一起使用，表示一个 size_t 值 (sizeof 返回的类型）(C99)
|^          | 示例："%zd"和"%12zx"

Table: printf() 修饰符 {#tbl:printf_modifier}

重点掌握： **%ld %lf %10d  %10.3f %.3f**

##### printf() 的标志

转换格式前的前缀标志，见 [@tbl:printf_flag]。

|标志符 | 意义|
|---|---------------------------|
|-     | 左对齐，打印在字段的左侧开始处
|^     | 示例："%-20s"
|+     | 有符号数若为正，前面打印加号；若为负，前面打印减号
|^     | 示例："%+6.2f"
|space | 有符号数若为正，前面打印前导空格（不打印加号）；若为负，前面打印减号。+标志或覆盖空格标志
|^     | 示例："% 6.2f"
|#     | 可选。若为%o 格式，则以 0 开始；若为%x 或%X 格式，则以 0x 或 0X 开始。对于所有浮点形式，#保证了即使不跟任何数字，也打印一个小数点字符。对于%g 和%G 格式，它防止尾随零被删除
|^     | 示例："%#o"、"%#8.0f"和"%+#10.3E"
|0     | 对于所有的数字格式，用前导零而不是用空格填充字段宽度。如果出现-标志或者指定了精度（对于整数）则忽略该标志
|^     | 示例："010d"和"%08.3f"

Table: printf() 的标志 {#tbl:printf_flag}

### C++

#### cin

```C {.line-numbers}
while(cin >> a >> s)
```
#### cin.get(char &ch)

输入一个字符

#### cin.getline(char *p,int count, char delim='\n')

输入到p所指向的count字节（实际为count-1个，最后一个为’\0’），默认结束符为\n（可自己设置）

#### cin.read(char *p, int count)

输入到p所指向的内存空间中count个字节，可读入空格

#### getline(istream &is, string &str,char delim)

string类中函数，输入到str，默认结束符为\n（可自己设置）

```C {.line-numbers}
#inlcude <string>

string str;
getline(cin,str,'a');
```

#### cout

```C {.line-numbers}
cout << a << endl;
```

#### cout.put(char ch)

输出一个字符

#### cout.write(const char *p,int count)

输出p所指向的内存空间中count个字节

